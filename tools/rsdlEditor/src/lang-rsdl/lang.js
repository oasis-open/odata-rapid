import { Parser } from 'lezer';
import { LezerLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@codemirror/highlight';
import { ifNotIn, completeFromList } from '@codemirror/autocomplete';
import { snippets } from './snippets';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,type:12, key:22, function:42, action:52, true:60, false:62, null:64, service:76, enum:82, flags:86};
const parser = Parser.deserialize({
    version: 13,
    states: "-UQYQPOOOhQPO'#DYOOQO'#Dd'#DdOOQO'#DZ'#DZQYQPOOOyQPO'#CaO!OQPO'#DROOQO,59t,59tO!WQPO,59tOOQO-E7X-E7XOOQO'#Cc'#CcO!iQPO,58{O!nQPO,59mO#YQPO,59mOOQO1G/`1G/`O#_QPO1G.gOOQO'#Ch'#ChO#pQPO'#CfO#uQPO'#CwOOQO'#Ce'#CeOOQO'#DT'#DTO#}QPO'#CfO$SQPO'#CpO$XQPO'#CuOyQPO'#DUO$^QPO1G/XO!nQPO1G/XO$cQPO7+$RO$hQPO,59QO$sQPO'#ClOOQO'#Cl'#ClO%[QPO,59cO%aQPO,59QO%fQPO,59[O%fQPO,59aO%kQPO,59pOOQO7+$s7+$sO%pQPO7+$sOOQO<<Gm<<GmO%uQPO'#CkO#uQPO'#CoOOQO'#Cj'#CjOOQO1G.l1G.lO&WQPO'#D[O&`QPO,59WO'YQPO1G.}O$hQPO1G.lO'aQPO'#CrO'iQPO1G.vOOQO1G.{1G.{O'nQPO1G/[OOQO<<H_<<H_OOQO,59Y,59YO'vQPO,59ZOOQO,59v,59vOOQO-E7Y-E7YO'{QPO'#C}OOQO'#Cy'#CyOOQO'#Cx'#CxOOQO7+$i7+$iO(TQPO7+$iOOQO7+$W7+$WO([QPO'#CtO(aQPO'#CsO(iQPO,59^O$hQPO7+$bO(nQPO'#DWO(vQPO7+$vOOQO1G.u1G.uOOQO'#D^'#D^O({QPO,59iO)ZQPO,59iO)`QPO'#DQO)hQPO<<HTO$hQPO,59`O#}QPO'#D]O)mQPO,59_OOQO1G.x1G.xOOQO<<G|<<G|OOQO'#D`'#D`O)uQPO,59rOOQO<<Hb<<HbOOQO-E7[-E7[O)}QPO1G/TO&wQPO'#D_O*]QPO,59lOOQOAN=oAN=oOOQO1G.z1G.zOOQO,59w,59wOOQO-E7Z-E7ZOOQO-E7^-E7^OOQO,59y,59yOOQO-E7]-E7]",
    stateData: "*e~O!VOSPOS~ORQOUTOvUO!^PO~ORQOUTOvUO!]VO!^PO~ORYO~ORYOW[O~ORQOUTOvUO!]^O!^PO~OW_O~OR`OZeOefOjgOyhO{hO!`bOSwP~OWjO~OR`OZeOefOjgO!`bO~O]lO~ORmOanO~OR`O~ORqO~ORrO~OStO~OSvO~ORmOanO!ZxO~O!X{O]`XS`X!Y`X![`X!]`X!_`X~O]}O~O]!OO~O!^!PO~OW!SO~OS!TO~O!Y!UOS_X![_X!]_X!__X~OR!WOa!WO~O!X{O]`aS`a!Y`a![`a!]`a!_`a~On!ZOo!ZOp!ZOr!YOs!ZO~O!Z!^O~P&wOR`O!]gP~O]!cO~OR!dOSzP~O![!fO~Or!gO!X!iO~O![tP~P&wO]!lO~O!_!mO!]gX~O!]!oO~OR!qOSzX~OS!sO~Or!gOSqa![qa!_qa~Or!gO~O!_!vO![tX~O![!xO~O!_!mO!]ga~OR!qOSza~Or!gOSqi![qi!_qi~O!_!vO![ta~O",
    goto: "&Q!XPPPPP!YP!`P!i!pP!uP#R#_#hP#_#r!pP#x$O$R!pP!p$X$bPPP$gPP$l!YP$o$uP$yP!Y$|%W%^%d%n%tPPP%zXQOPSWQZTQ]URshSd[jRk_Vc[_jUa[_jQpeT!`!P!mQzlQ!_!OQ!p!cR!y!lWyl!O!c!lR!VxQobZwlx!O!c!lXyl!O!c!lQ!QqR!RrR!b!PQ!a!PR!z!mQ!]}Q!j!^R!}!vV![}!^!vV!Z}!^!vR!k!^Qi[RujTd[jR!e!SQSOQWPTXSWQ|mR!X|Q!n!aR!{!nQ!h!YS!t!h!uR!u!iQ!w!jR#O!wQ!r!dR!|!rXROPSW",
    nodeNames: "âš  LineComment Program Identifier } TypeDefinition type DefinitionName { TypeBodyDefinition FieldDefinition key VariableName : FieldType RequiredType TypeRefName CapitalIdentifier OptionalType MultiValuedType FunctionDefinition function FormalParameters CommaSepParams FormalParameter ActionDefinition action AnnotationDefinition AnnotationValue Literal true false null NumberLiteral Digits StringLiteral CommaSepAnnotationValues ServiceDefinition service ServiceBodyDefinition EnumDefinition enum SpaceSepIds flags Application",
    maxTerm: 62,
    skippedNodes: [0,1],
    repeatNodeCount: 6,
    tokenData: "&W~RfXY!gYZ!g]^!gpq!grs!xst#ptu#{xy$ayz$f|}$k!O!P$p!Q![$u![!]$}!a!b%S!b!c%X!c!}%^!}#O%r#P#Q%w#R#S#{#T#o#{#o#p%|#q#r&R~!lS!V~XY!gYZ!g]^!gpq!g~!{UOY!xZr!xrs#_s#O!x#O#P#d#P~!x~#dOs~~#gROY!xYZ!xZ~!x~#uQP~OY#pZ~#p~$QTR~tu#{!Q![#{!c!}#{#R#S#{#T#o#{~$fO!^~~$kO!]~~$pO!_~~$uO!X~~$zPr~!Q![$u~%SO]~~%XO!Y~~%^O!`~~%cTa~tu%^!Q![%^!c!}%^#R#S%^#T#o%^~%wO!Z~~%|O![~~&ROW~~&WOS~",
    tokenizers: [0],
    topRules: {"Program":[0,2]},
    specialized: [{term: 3, get: value => spec_Identifier[value] || -1}],
    tokenPrec: 0
});

const rsdlLanguage = LezerLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Application: delimitedIndent({ closing: ")", align: false })
            }),
            foldNodeProp.add({
                Application: foldInside
            }),
            styleTags({
                Identifier: tags.variableName,
                CapitalIdentifier: tags.typeName,
                Boolean: tags.bool,
                String: tags.string,
                VariableName: tags.lineComment,
                LineComment: tags.lineComment,
                "type service enum flags": tags.definitionKeyword,
                "key": [tags.emphasis, tags.atom],
                "( )": tags.paren,
                "{ }": tags.brace,
            })
        ]
    }),
    languageData: {
        commentTokens: { line: "#" }
    }
});

function rsdl() {
    return new LanguageSupport(rsdlLanguage, rsdlLanguage.data.of({
        autocomplete: ifNotIn(["LineComment", "StringLiteral"], completeFromList(snippets))
    }));
}


export { rsdl, rsdlLanguage };